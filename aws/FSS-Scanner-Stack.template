AWSTemplateFormatVersion: 2010-09-09

Description: Trend Micro File Storage Security scanner stack

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "[ Customizable section ]"
        Parameters:
          - KMSKeyARNForQueueSSE
      - Label:
          default: "[ Optional: resource prefixes ] Warning: Do not modify these fields when you update the stack. This may cause management problems. The maximum prefix length is 50 characters."
        Parameters:
          - IAMRolePrefix
          - IAMPolicyPrefix
          - LambdaFunctionPrefix
          - LambdaLayerPrefix
          - SQSQueuePrefix
      - Label:
          default: "[ Optional: Deploy in VPC ] Warning: Make sure the subnets have access to domains .amazonaws.com and .trendmicro.com over HTTPS"
        Parameters:
          - SubnetIDs
          - SecurityGroupIDs
          - NetworkProxy
      - Label:
          default: "[ Warning: Do not modify the fields below. Modifications may cause your deployment to fail. ]"
        Parameters:
          - FSSBucketName
          - FSSKeyPrefix
          - TrendMicroManagementAccount
          - CloudOneRegion
          - ExternalID

    ParameterLabels:
      CloudOneRegion:
        default: Trend Micro Cloud One region
      ExternalID:
        default: ExternalID
      FSSBucketName:
        default: Stack package location
      FSSKeyPrefix:
        default: Version
      IAMPolicyPrefix:
        default: Prefix for IAM policy name
      IAMRolePrefix:
        default: Prefix for IAM role name
      KMSKeyARNForQueueSSE:
        default: KMSKeyARNForQueueSSE
      LambdaFunctionPrefix:
        default: "Prefix for Lambda function name [ Warning: Do not modify this field when you update the stack. Modifications may cause your update to fail. ]"
      LambdaLayerPrefix:
        default: Prefix for Lambda layer name
      NetworkProxy:
        default: NetworkProxy
      SecurityGroupIDs:
        default: SecurityGroupIDs
      SQSQueuePrefix:
        default: Prefix for SQS queue name
      SubnetIDs:
        default: SubnetIDs
      TrendMicroManagementAccount:
        default: File Storage Security management account

Parameters:
  CloudOneRegion:
    Description: The region of the Trend Micro Cloud One services.
    Type: String
    Default: us-1
  ExternalID:
    Description: "The External ID is for future use with updating Lambdas and also to address and prevent the 'confused deputy' problem."
    Type: String
  FSSBucketName:
    AllowedPattern: ^[0-9a-z]+([0-9a-z-]*[0-9a-z])*$
    ConstraintDescription:
      File Storage Security bucket name can include numbers, lowercase
      letters, and hyphens (-). It cannot start or end with a hyphen
      (-).
    Default: file-storage-security
    Description: ""
    Type: String
  FSSKeyPrefix:
    AllowedPattern: ^[0-9a-zA-Z-/]*$
    ConstraintDescription:
      File Storage Security key prefix can include numbers, lowercase letters,
      uppercase letters, hyphens (-), and forward slash (/).
    Default: latest/
    Description: ""
    Type: String
  IAMPolicyPrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9+=,.@\-_]+-$
    ConstraintDescription: Prefix for IAM policy name can be empty or include alphanumeric and '+=,.@-_' characters and must end with a hyphen. The maximum length is 50 characters.
    Default: ''
    Description: Prefix for the name of the IAM Policies. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  IAMRolePrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9+=,.@\-_]+-$
    ConstraintDescription: Prefix for IAM role name can be empty or include alphanumeric and '+=,.@-_' characters and must end with a hyphen. The maximum length is 50 characters.
    Default: ''
    Description: Prefix for the name of the IAM roles being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  KMSKeyARNForQueueSSE:
    Default: ''
    Description: The ARN for the KMS master key used to encrypt messages in SQS. Leave it blank if you haven't used your own CMK for SQS server-side encryption.
    Type: String
  LambdaFunctionPrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9_\-]+-$
    ConstraintDescription: Prefix for Lambda function name can be empty or include letters, numbers, hyphens (-), and underscores (_) and must end with a hyphen. The maximum length is 50 characters.
    Default: ''
    Description: Prefix for the name of the Lambda functions being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  LambdaLayerPrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9_\-]+-$
    ConstraintDescription: Prefix for Lambda layer name can be empty or include letters, numbers, hyphens (-), and underscores (_) and must end with a hyphen. The maximum length is 50 characters.
    Default: ''
    Description: Prefix for the name of the Lambda layers being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  NetworkProxy:
    Default: ''
    Description: Network proxy setting in the format scheme://[user:pass@]host:port, for example http://proxy.server:8080. Leave it blank if you don't want Lambda functions to connect to an explicit proxy in the VPC.
    Type: String
  SecurityGroupIDs:
    Default: ''
    Description: A comma-separated list of VPC Security Group IDs that are attached to Lambda functions. Leave it blank if you don't want to attach Lambda functions to a VPC.
    Type: CommaDelimitedList
  SQSQueuePrefix:
    AllowedPattern: ^$|^[a-zA-Z0-9_\-]+-$
    ConstraintDescription: Prefix for SQS queue name can be empty or include alphanumeric characters, hyphens (-), and underscores (_) and must end with a hyphen. The maximum length is 50 characters.
    Default: ''
    Description: Prefix for the name of SQS queues being deployed. Must end with a hyphen (-).
    Type: String
    MaxLength: 50
  SubnetIDs:
    Default: ''
    Description: A comma-separated list of VPC Subnet IDs that are attached to Lambda functions. Leave it blank if you don't want to attach Lambda functions to a VPC.
    Type: CommaDelimitedList
  TrendMicroManagementAccount:
    AllowedPattern: ^[0-9]*$
    ConstraintDescription: AWS account ID.
    Default: 415485722356
    Description: This account will be given permission to modify the stacks for upgrades and troubleshooting purposes.
    Type: String

Mappings:
  CloudOneRegionAttributes:
    us-east-1: # for backward compatibility
      AWSRegion: us-east-1
    us-1:
      AWSRegion: us-east-1
    trend-us-1:
      AWSRegion: us-east-2
    in-1:
      AWSRegion: ap-south-1
    gb-1:
      AWSRegion: eu-west-2
    au-1:
      AWSRegion: ap-southeast-2
    de-1:
      AWSRegion: eu-central-1
    jp-1:
      AWSRegion: ap-northeast-1

Conditions:
  HasIAMPolicyPrefix:
    !Not [!Equals ['', !Ref IAMPolicyPrefix]]
  HasIAMRolePrefix:
    !Not [!Equals ['', !Ref IAMRolePrefix]]
  HasLambdaFunctionPrefix:
    !Not [!Equals ['', !Ref LambdaFunctionPrefix]]
  HasLambdaLayerPrefix:
    !Not [!Equals ['', !Ref LambdaLayerPrefix]]
  HasSQSQueuePrefix:
    !Not [!Equals ['', !Ref SQSQueuePrefix]]
  IsQueueSSEKMSEnabled:
    !Not [!Equals ['', !Ref KMSKeyARNForQueueSSE]]
  IsVPCEnabled: !And
    - !Not [!Equals ['', !Select [0, !Ref SubnetIDs]]]
    - !Not [!Equals ['', !Select [0, !Ref SecurityGroupIDs]]]
  IsProxyEnabled: !And
    - !Condition IsVPCEnabled
    - !Not [!Equals ['', !Ref NetworkProxy]]

Resources:
  GetLambdaLastConfig:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join ['', [!Ref LambdaFunctionPrefix, 'Conf-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      Description: Get Lambda config before creating/updating alias on Lambda function
      Handler: index.handler
      Runtime: python3.8
      Role: !GetAtt GetLambdaLastConfigExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          HTTPS_PROXY: !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds: !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      Code:
        ZipFile: |
          import boto3
          import traceback
          import json
          import urllib.request
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"
          cfn = boto3.client('cloudformation')
          lambda_client = boto3.client('lambda')
          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False):
              responseUrl = event['ResponseURL']
              print(responseUrl)
              responseBody = {}
              responseBody['Status'] = responseStatus
              responseBody['Reason'] = 'See the details in CloudWatch Log Stream: ' + context.log_stream_name
              responseBody['PhysicalResourceId'] = physicalResourceId or context.log_stream_name
              responseBody['StackId'] = event['StackId']
              responseBody['RequestId'] = event['RequestId']
              responseBody['LogicalResourceId'] = event['LogicalResourceId']
              responseBody['NoEcho'] = noEcho
              responseBody['Data'] = responseData
              json_responseBody = json.dumps(responseBody)
              # Do not print response body cause it might contains license (JWT)
              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }
              request = urllib.request.Request(responseUrl, headers=headers, data=json_responseBody.encode('utf-8'), method='PUT')
              try:
                  with urllib.request.urlopen(request) as response:
                      print("Status code: " + response.reason)
              except Exception as e:
                  print("send(..) failed executing requests.put(..): " + str(e))
          def handler(event, context):
              print(event)
              status = SUCCESS
              response_data = { 'Environment': {}, 'Layers': [] }
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      stack_id = event['StackId']
                      lambda_arn_output_key = event['ResourceProperties']['LambdaARNOutputKey']
                      lambda_alias_arn_output_key = event['ResourceProperties']['LambdaAliasARNOutputKey']

                      function_arn = None
                      cfn_response = cfn.describe_stacks(StackName=stack_id)
                      stack_outputs = cfn_response['Stacks'][0].get('Outputs', [])
                      for output in stack_outputs:
                          if output['OutputKey'] == lambda_alias_arn_output_key:
                              function_arn = output['OutputValue']
                              break
                          elif output['OutputKey'] == lambda_arn_output_key:
                              function_arn = output['OutputValue']

                      if function_arn:
                          function_config = lambda_client.get_function_configuration(FunctionName=function_arn)
                          response_data['Environment'] = function_config['Environment']['Variables']
                          response_data['Layers'] = function_config['Layers']
              except Exception as ex:
                  print('Unhandled exception: ' + str(ex))
                  traceback.print_exc()
                  status = FAILED
              finally:
                  send(event, context, status, response_data)
  GetLambdaLastConfigExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join ['', [!Ref IAMRolePrefix, 'Conf-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !If
          - IsVPCEnabled
          - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
          - !Ref AWS::NoValue
      Policies:
        - PolicyName: get-lambda-last-config
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                Resource: !Ref AWS::StackId
              - Effect: Allow
                Action:
                  - lambda:GetFunctionConfiguration
                Resource:
                  - !If
                    - HasLambdaFunctionPrefix
                    - !Join
                      - ''
                      - - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:'
                        - !Ref LambdaFunctionPrefix
                        - 'Scan-'
                        - !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]
                        - '*'
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*ScannerLambda*
                  - !If
                    - HasLambdaFunctionPrefix
                    - !Join
                      - ''
                      - - !Sub 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:'
                        - !Ref LambdaFunctionPrefix
                        - 'SDL-'
                        - !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:*ScannerDeadLetterLambda*
  CreateLambdaAliasLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join ['', [!Ref LambdaFunctionPrefix, 'alias-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      Description: Create Lambda alias on Lambda function
      Handler: index.handler
      Runtime: python3.8
      Role: !GetAtt CreateLambdaAliasExecutionRole.Arn
      Timeout: 120
      Environment:
        Variables:
          HTTPS_PROXY: !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds: !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
      Code:
        ZipFile: |
          import boto3
          import traceback
          import json
          import urllib.request
          import time
          SUCCESS = "SUCCESS"
          FAILED = "FAILED"
          lambda_client = boto3.client('lambda')
          def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False):
              responseUrl = event['ResponseURL']
              print(responseUrl)
              responseBody = {}
              responseBody['Status'] = responseStatus
              responseBody['Reason'] = 'See the details in CloudWatch Log Stream: ' + context.log_stream_name
              responseBody['PhysicalResourceId'] = physicalResourceId or context.log_stream_name
              responseBody['StackId'] = event['StackId']
              responseBody['RequestId'] = event['RequestId']
              responseBody['LogicalResourceId'] = event['LogicalResourceId']
              responseBody['NoEcho'] = noEcho
              responseBody['Data'] = responseData
              json_responseBody = json.dumps(responseBody)
              print("Response body:\n" + json_responseBody)
              headers = {
                  'content-type' : '',
                  'content-length' : str(len(json_responseBody))
              }
              request = urllib.request.Request(responseUrl, headers=headers, data=json_responseBody.encode('utf-8'), method='PUT')
              try:
                  with urllib.request.urlopen(request) as response:
                      print("Status code: " + response.reason)
              except Exception as e:
                  print("send(..) failed executing requests.put(..): " + str(e))
          def publish_version_with_retry(function, retry_attempts=6):
              try:
                  return lambda_client.publish_version(FunctionName=function)
              except lambda_client.exceptions.ResourceConflictException as e:
                  if retry_attempts > 0:
                      print('publish_version failed with ResourceConflictException, retrying in 10 seconds...')
                      time.sleep(10)
                      return publish_version_with_retry(function, retry_attempts-1)
                  else: raise e
          def create_alias(function, name):
              version_result = publish_version_with_retry(function)
              return lambda_client.create_alias(FunctionName=function, Name=name, FunctionVersion=version_result['Version'])
          def update_alias(function, name):
              version_result = publish_version_with_retry(function)
              return lambda_client.update_alias(FunctionName=function, Name=name, FunctionVersion=version_result['Version'], RoutingConfig={})
          def delete_alias(function, name):
              lambda_client.delete_alias(FunctionName=function, Name=name)
          def get_function_configuration(function, qualifier=None):
              if (qualifier is not None):
                  return lambda_client.get_function_configuration(FunctionName=function, Qualifier=qualifier)
              else:
                  return lambda_client.get_function_configuration(FunctionName=function)
          def update_function_configuration(function, environments, layers):
              lambda_client.update_function_configuration(FunctionName=function, Environment=environments, Layers=layers)
          def replace_environments(env_vars_to_recover, last_env_vars, current_environments):
              for env_var in env_vars_to_recover:
                  current_environments['Variables'][env_var] = last_env_vars.get(env_var, '')
              return current_environments
          def find_recover_layer_arn(layers, keyword):
              found_arns = [layer_arn for layer_arn in layers if keyword in layer_arn]
              return found_arns[0] if len(found_arns) > 0 else ''
          def is_not_match_layer(layer_arn, keywords):
              return len(list(filter(lambda keyword: keyword in layer_arn, keywords))) == 0
          def replace_layers(layers_to_recover, last_layers, current_layers):
              get_arn = lambda layer: layer['Arn']
              old_layer_arns = list(map(get_arn, last_layers))
              current_layer_arns = list(map(get_arn, current_layers))
              for recover_layer, replacing_layers in layers_to_recover.items():
                  recover_layer_arn = find_recover_layer_arn(old_layer_arns, recover_layer)
                  if len(recover_layer_arn) == 0: break
                  current_layer_arns = [layer_arn for layer_arn in current_layer_arns if is_not_match_layer(layer_arn, replacing_layers)]
                  current_layer_arns.append(recover_layer_arn)
              return current_layer_arns
          def recover_lambda_function_config(current_function_name, last_env_vars, last_layers, env_vars_to_recover, layers_to_recover):
              current_version_info = get_function_configuration(current_function_name)
              new_environments = replace_environments(env_vars_to_recover, last_env_vars, current_version_info['Environment'])
              new_layers = replace_layers(layers_to_recover, last_layers, current_version_info.get('Layers', []))
              update_function_configuration(current_function_name, new_environments, new_layers)
          def handler(event, context):
              # Do not print LastEnvVars values cause it might contain license (JWT)
              last_env_vars = event['ResourceProperties'].pop('LastEnvVars', {})
              event.get('OldResourceProperties', {}).pop('LastEnvVars', None)
              print(event)
              print('ResourceProperties.LastEnvVars:', last_env_vars.keys())
              status = SUCCESS
              response_data = {}
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      function_name = event['ResourceProperties']['FunctionName']
                      alias_name = event['ResourceProperties']['Name']
                      last_layers = event['ResourceProperties'].get('LastLayers', [])
                      env_vars_to_recover = event['ResourceProperties'].get('EnvVarsToRecover', [])
                      layers_to_recover = event['ResourceProperties'].get('LayersToRecover', {})
                      recover_lambda_function_config(function_name, last_env_vars, last_layers, env_vars_to_recover, layers_to_recover)
                      if event['RequestType'] == 'Create':
                          alias_result = create_alias(function_name, alias_name)
                      else:
                          old_function_name = event['OldResourceProperties']['FunctionName']
                          old_alias_name = event['OldResourceProperties']['Name']
                          if function_name == old_function_name and alias_name == old_alias_name:
                              alias_result = update_alias(function_name, alias_name)
                          else:
                              alias_result = create_alias(function_name, alias_name)
                              delete_alias(old_function_name, old_alias_name)
                      response_data = {'Arn': alias_result['AliasArn']}
              except Exception as ex:
                  print('Unhandled exception: ' + str(ex))
                  traceback.print_exc()
                  status = FAILED
              finally:
                  send(event, context, status, response_data, response_data.get('Arn', None))
  CreateLambdaAliasExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join ['', [!Ref IAMRolePrefix, 'Ver-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !If
          - IsVPCEnabled
          - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
          - !Ref AWS::NoValue
      Policies:
        - PolicyName: create-lambda-function-version-alias
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:PublishVersion
                  - lambda:CreateAlias
                  - lambda:UpdateAlias
                  - lambda:DeleteAlias
                  - lambda:GetFunctionConfiguration
                  - lambda:UpdateFunctionConfiguration
                Resource:
                  - !GetAtt ScannerLambda.Arn
                  - !GetAtt ScannerDeadLetterLambda.Arn
              - Effect: Allow
                Action:
                  - lambda:GetLayerVersion
                Resource:
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${TrendMicroManagementAccount}:layer:Scanner*LambdaLayer*:*
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:Scanner*LambdaLayer:*
                  - !If
                    - HasLambdaLayerPrefix
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:${LambdaLayerPrefix}Scanner*:*
                    - !Ref AWS::NoValue

  ScannerQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - HasSQSQueuePrefix
        - !Join ['', [!Ref SQSQueuePrefix, 'ScannerQueue-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      DelaySeconds: 0
      MaximumMessageSize: 262144
      MessageRetentionPeriod: 3600
      ReceiveMessageWaitTimeSeconds: 0
      VisibilityTimeout: 720
      RedrivePolicy:
        deadLetterTargetArn: !GetAtt ScannerDLQ.Arn
        maxReceiveCount: 2
      KmsDataKeyReusePeriodSeconds: !If
        - IsQueueSSEKMSEnabled
        - 86400
        - !Ref AWS::NoValue
      KmsMasterKeyId: !If
        - IsQueueSSEKMSEnabled
        - !Ref KMSKeyARNForQueueSSE
        - !Ref AWS::NoValue
  ScannerQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Sid: send_message_from_accounts
            Effect: Allow
            Principal: !Ref AWS::NoValue
            Action:
              - sqs:SendMessage
            Resource: !GetAtt ScannerQueue.Arn
      Queues:
        - !Ref ScannerQueue
  ScannerDLQ:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !If
        - HasSQSQueuePrefix
        - !Join ['', [!Ref SQSQueuePrefix, 'ScannerDLQ-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      DelaySeconds: 0
      MaximumMessageSize: 262144
      MessageRetentionPeriod: 3600
      ReceiveMessageWaitTimeSeconds: 0
      VisibilityTimeout: 720
      KmsDataKeyReusePeriodSeconds: !If
        - IsQueueSSEKMSEnabled
        - 86400
        - !Ref AWS::NoValue
      KmsMasterKeyId: !If
        - IsQueueSSEKMSEnabled
        - !Ref KMSKeyARNForQueueSSE
        - !Ref AWS::NoValue

  ScannerLambda:
    Type: AWS::Lambda::Function
    DependsOn: ScannerLambdaLastConfig
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join ['', [!Ref LambdaFunctionPrefix, 'Scan-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      Code:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}lambda/scanner-lambda-python.zip
      Handler: lambdas.handler.lambda_handler
      Environment:
        Variables:
          queueURL: !Ref ScannerQueue
          telemetry_sns_arn: !Sub
            - arn:${AWS::Partition}:sns:${Region}:${TrendMicroManagementAccount}:fss-telemetry-topic
            - Region: !FindInMap [CloudOneRegionAttributes, !Ref CloudOneRegion, AWSRegion]
          stackARN: !Ref AWS::StackId
          HTTPS_PROXY: !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      MemorySize: 512
      Role: !GetAtt ScannerExecutionRole.Arn
      Runtime: python3.6
      Timeout: 120
      Layers:
        - !Ref ScannerPatternLambdaLayer
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds: !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
  ScannerLambdaLastConfig:
    Type: Custom::ScannerLambdaLastConfig
    Properties:
      ServiceToken: !GetAtt GetLambdaLastConfig.Arn
      LambdaARNOutputKey: ScannerLambdaARN
      LambdaAliasARNOutputKey: ScannerLambdaAliasARN
      Modified: 20210812.1
      # Template parameters
      CloudOneRegion: !Ref CloudOneRegion
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      NetworkProxy: !Ref NetworkProxy
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
      TrendMicroManagementAccount: !Ref TrendMicroManagementAccount
  ScannerLambdaAlias:
    Type: Custom::ScannerLambdaAlias
    Properties:
      ServiceToken: !GetAtt CreateLambdaAliasLambda.Arn
      FunctionName: !GetAtt ScannerLambda.Arn
      Name: TM-FSS-MANAGED
      Modified: 20210901.1
      # Template parameters
      CloudOneRegion: !Ref CloudOneRegion
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      NetworkProxy: !Ref NetworkProxy
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
      TrendMicroManagementAccount: !Ref TrendMicroManagementAccount
      # Other inputs
      LastEnvVars: !GetAtt ScannerLambdaLastConfig.Environment
      LastLayers: !GetAtt ScannerLambdaLastConfig.Layers
      EnvVarsToRecover:
        - LICENSE
      LayersToRecover:
        # Find the layer pushed by FSS backend and replace the layer created by templates.
        # The layer name could be:
        # 1. ScannerPatternLambdaLayer_xxxxxx (pushed by FSS backend)
        # 2. ScannerPatternLambdaLayer (created by templates without prefix parameters)
        # 3. <prefix>-ScannerPattern (created by templates with prefix parameters)
        ScannerPatternLambdaLayer_:
          - ScannerPattern
  ScannerLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [/, [/aws/lambda, !Ref ScannerLambda]]
      RetentionInDays: 90
  ScannerPatternLambdaLayer:
    Type: AWS::Lambda::LayerVersion
    Properties:
      LayerName: !If
        - HasLambdaLayerPrefix
        - !Join ['', [!Ref LambdaLayerPrefix, 'ScannerPattern']]
        - !Ref AWS::NoValue
      Content:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}patterns/pattern-icrc-269.zip
      Description: Anti-Malware pattern layer for scanner lambda function.
  ScannerEventSourceFromScannerQueue:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      Enabled: true
      EventSourceArn: !GetAtt ScannerQueue.Arn
      FunctionName: !GetAtt ScannerLambdaAlias.Arn

  ScannerDeadLetterLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !If
        - HasLambdaFunctionPrefix
        - !Join ['', [!Ref LambdaFunctionPrefix, 'SDL-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      Code:
        S3Bucket: !Sub ${FSSBucketName}-${AWS::Region}
        S3Key: !Sub ${FSSKeyPrefix}lambda/scanner-dlq-lambda-python.zip
      Handler: lambdas.scanner_dlq_handler.lambda_handler
      Environment:
        Variables:
          stackARN: !Ref AWS::StackId
          HTTPS_PROXY: !If [IsProxyEnabled, !Ref NetworkProxy, !Ref AWS::NoValue]
      MemorySize: 128
      Role: !GetAtt ScannerDeadLetterExecutionRole.Arn
      Runtime: python3.8
      Timeout: 60
      VpcConfig:
        SubnetIds: !If [IsVPCEnabled, !Ref SubnetIDs, !Ref AWS::NoValue]
        SecurityGroupIds: !If [IsVPCEnabled, !Ref SecurityGroupIDs, !Ref AWS::NoValue]
  ScannerDeadLetterLambdaAlias:
    Type: Custom::ScannerDeadLetterLambdaAlias
    Properties:
      ServiceToken: !GetAtt CreateLambdaAliasLambda.Arn
      FunctionName: !GetAtt ScannerDeadLetterLambda.Arn
      Name: TM-FSS-MANAGED
      Modified: 20210708.1
      # Template parameters
      FSSBucketName: !Ref FSSBucketName
      FSSKeyPrefix: !Ref FSSKeyPrefix
      NetworkProxy: !Ref NetworkProxy
      SecurityGroupIDs: !Ref SecurityGroupIDs
      SubnetIDs: !Ref SubnetIDs
  ScannerDeadLetterLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Join [/, [/aws/lambda, !Ref ScannerDeadLetterLambda]]
      RetentionInDays: 90
  ScannerDeadLetterEventSourceFromDLQ:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      BatchSize: 1
      Enabled: true
      EventSourceArn: !GetAtt ScannerDLQ.Arn
      FunctionName: !GetAtt ScannerDeadLetterLambdaAlias.Arn

  ScannerExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join ['', [!Ref IAMRolePrefix, 'Scan-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !If
          - IsVPCEnabled
          - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
          - !Ref AWS::NoValue
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                  - sqs:ChangeMessageVisibility
                Resource: !GetAtt ScannerQueue.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Sub
                    - arn:${AWS::Partition}:sns:${Region}:${TrendMicroManagementAccount}:fss-telemetry-topic
                    - Region: !FindInMap [CloudOneRegionAttributes, !Ref CloudOneRegion, AWSRegion]
                  - !Sub arn:${AWS::Partition}:sns:*:*:*-ScanResultTopic-*
              - Effect: Allow # https://docs.aws.amazon.com/AmazonS3/latest/userguide/olap-policies.html
                Action:
                  - s3-object-lambda:WriteGetObjectResponse
                Resource: '*'
  ScannerExecutionRoleKMSDecryptPolicyForSQS:
    Type: AWS::IAM::Policy
    Condition: IsQueueSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ['', [!Ref IAMPolicyPrefix, 'kms-permission-for-sqs']]
        - 'kms-permission-for-sqs'
      Roles:
        - !Ref ScannerExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:Decrypt
            Resource: !Ref KMSKeyARNForQueueSSE

  ScannerDeadLetterExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join ['', [!Ref IAMRolePrefix, 'SDL-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - !If
          - IsVPCEnabled
          - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
          - !Ref AWS::NoValue
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource: !GetAtt ScannerDLQ.Arn
              - Effect: Allow
                Action:
                  - sns:Publish
                Resource:
                  - !Sub
                    - arn:${AWS::Partition}:sns:${Region}:${TrendMicroManagementAccount}:fss-telemetry-topic
                    - Region: !FindInMap [CloudOneRegionAttributes, !Ref CloudOneRegion, AWSRegion]
                  - !Sub arn:${AWS::Partition}:sns:*:*:*-ScanResultTopic-*
  ScannerDeadLetterExecutionRoleKMSDecryptPolicyForSQS:
    Type: AWS::IAM::Policy
    Condition: IsQueueSSEKMSEnabled
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ['', [!Ref IAMPolicyPrefix, 'kms-permission-for-sqs']]
        - 'kms-permission-for-sqs'
      Roles:
        - !Ref ScannerDeadLetterExecutionRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - kms:Decrypt
            Resource: !Ref KMSKeyARNForQueueSSE

  ManagementRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !If
        - HasIAMRolePrefix
        - !Join ['', [!Ref IAMRolePrefix, 'Mgmt-', !Select [0, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]]]
        - !Ref AWS::NoValue
      Path: /
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Ref TrendMicroManagementAccount
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                sts:ExternalId: !Ref ExternalID
      Policies:
        - PolicyName: stack-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:CreateChangeSet
                  - cloudformation:ListStackResources
                  - cloudformation:DescribeStacks
                  - cloudformation:DescribeStackEvents
                  - cloudformation:DescribeStackResources
                  - cloudformation:DescribeStackResource
                  - cloudformation:DetectStackDrift
                  - cloudformation:DetectStackResourceDrift
                  - cloudformation:DescribeStackResourceDrifts
                  - cloudformation:GetStackPolicy
                  - cloudformation:GetTemplate
                Resource: !Ref AWS::StackId
        - PolicyName: queue-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - sqs:SetQueueAttributes
                  - sqs:GetQueueAttributes
                  - sqs:ListDeadLetterSourceQueues
                Resource:
                  - !GetAtt ScannerQueue.Arn
                  - !GetAtt ScannerDLQ.Arn
        - PolicyName: lambda-management
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - lambda:UpdateFunctionCode
                  - lambda:UpdateFunctionConfiguration
                  - lambda:GetFunctionConfiguration
                  - lambda:PublishVersion
                  - lambda:ListVersionsByFunction
                  - lambda:CreateAlias
                  - lambda:UpdateAlias
                  - lambda:DeleteAlias
                  - lambda:ListAliases
                  - lambda:GetAlias
                  - lambda:GetFunction
                  - lambda:ListProvisionedConcurrencyConfigs
                  - lambda:GetProvisionedConcurrencyConfig
                  - lambda:GetFunctionConcurrency
                Resource:
                  - !GetAtt ScannerLambda.Arn
                  - !GetAtt ScannerDeadLetterLambda.Arn
                  - !Sub ${ScannerLambda.Arn}:*
                  - !Sub ${ScannerDeadLetterLambda.Arn}:*
              - Effect: Allow
                Action:
                  - lambda:GetEventSourceMapping
                Resource:
                  - !Sub
                    - arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:event-source-mapping:${MappingID}
                    - MappingID: !Ref ScannerEventSourceFromScannerQueue
                  - !Sub
                    - arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:event-source-mapping:${MappingID}
                    - MappingID: !Ref ScannerDeadLetterEventSourceFromDLQ
              - Effect: Allow
                Action:
                  - lambda:GetLayerVersion
                Resource:
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${TrendMicroManagementAccount}:layer:Scanner*LambdaLayer*:*
                  - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:Scanner*LambdaLayer:*
                  - !If
                    - HasLambdaLayerPrefix
                    - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:layer:${LambdaLayerPrefix}Scanner*:*
                    - !Ref AWS::NoValue
        - PolicyName: lambda-logs-access
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:DescribeLogStreams
                  - logs:GetLogEvents
                  - logs:StartQuery
                  - logs:StopQuery
                  - logs:GetQueryResults
                  - logs:FilterLogEvents
                Resource:
                  - !GetAtt ScannerLogGroup.Arn
                  - !GetAtt ScannerDeadLetterLogGroup.Arn
  ManagementRoleGetRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: !If
        - HasIAMPolicyPrefix
        - !Join ['', [!Ref IAMPolicyPrefix, 'role-management']]
        - 'role-management'
      Roles:
        - !Ref ManagementRole
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action:
              - iam:GetRolePolicy
            Resource: !GetAtt ManagementRole.Arn

Outputs:
  CloudOneRegion:
    Value: !Ref CloudOneRegion
    Description: The region of the Trend Micro Cloud One services.
  ScannerLambdaARN:
    Value: !GetAtt ScannerLambda.Arn
  ScannerLambdaAliasARN:
    Value: !GetAtt ScannerLambdaAlias.Arn
  ScannerQueueURL:
    Value: !Ref ScannerQueue
    Description: The SQS URL for storage stacks to publish events to.
  ScannerStackManagementRoleARN:
    Value: !GetAtt ManagementRole.Arn
    Description: The ARN of the IAM role for File Storage Security backend services to manage the deployed resources.
